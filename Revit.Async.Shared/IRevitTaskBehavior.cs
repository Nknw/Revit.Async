using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;
using Autodesk.Revit.UI;
using Revit.Async.Entities;
using Revit.Async.Extensions;
using Revit.Async.ExternalEvents;
using Revit.Async.Interfaces;
using Revit.Async.Utils;

namespace Revit.Async
{
    public interface IRevitTaskBehavior
    {
        Task<TResult> RunAsync<TResult>(Func<UIApplication, TResult> function);
        Task<TResult> RunAsync<TResult>(Func<UIApplication, Task<TResult>> function);
        Task<TResult> RaiseGlobal<THandler, TParameter, TResult>(TParameter parameter)
            where THandler : IGenericExternalEventHandler<TParameter, TResult>;
        void RegisterGlobal<TParameter, TResult>(IGenericExternalEventHandler<TParameter, TResult> handler);
    }

    class DefaultRevitTaskBehavior : IRevitTaskBehavior
    {
        private ConcurrentDictionary<Type, ExternalEventPair> _asyncDelegateExternalEvents;
        private ConcurrentDictionary<Type, ExternalEventPair> _syncDelegateExternalEvents;
        private ConcurrentDictionary<Type, ExternalEventPair> _registeredExternalEvents;


        /// <summary>
        ///     Cache all the created <see cref="ExternalEvent" />s and their <see cref="IExternalEventHandler" /> running async
        ///     code
        /// </summary>
        private ConcurrentDictionary<Type, ExternalEventPair> AsyncDelegateExternalEvents =>
            _asyncDelegateExternalEvents ?? (_asyncDelegateExternalEvents = new ConcurrentDictionary<Type, ExternalEventPair>());

        /// <summary>
        ///     Use to create any other external events
        /// </summary>
        private ExternalEventPair ExternalEventCreator { get; set; }

        /// <summary>
        ///     Store the external events registered globally
        /// </summary>
        private ConcurrentDictionary<Type, ExternalEventPair> RegisteredExternalEvents =>
            _registeredExternalEvents ?? (_registeredExternalEvents = new ConcurrentDictionary<Type, ExternalEventPair>());

        /// <summary>
        ///     Cache all the created <see cref="ExternalEvent" />s and their <see cref="IExternalEventHandler" /> running sync
        ///     code
        /// </summary>
        private ConcurrentDictionary<Type, ExternalEventPair> SyncDelegateExternalEvents =>
            _syncDelegateExternalEvents ?? (_syncDelegateExternalEvents = new ConcurrentDictionary<Type, ExternalEventPair>());

        public DefaultRevitTaskBehavior()
        {
            if (ExternalEventCreator == null)
            {
                ExternalEventCreator = new ExternalEventPair(new SyncDelegateExternalEventHandler<ExternalEvent>());
            }
        }

        /// <summary>
        ///     Raise an <see cref="IGenericExternalEventHandler{TParameter,TResult}" /> and get the result.
        ///     If a the handler is not registered globally, find the RevitTask instance to raise it
        /// </summary>
        /// <typeparam name="THandler">The type of the <see cref="IGenericExternalEventHandler{TParameter,TResult}" /></typeparam>
        /// <typeparam name="TParameter">
        ///     The type of the parameter that
        ///     <see cref="IGenericExternalEventHandler{TParameter,TResult}" /> accepts
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The type of result that <see cref="IGenericExternalEventHandler{TParameter,TResult}" />
        ///     generates
        /// </typeparam>
        /// <param name="parameter">
        ///     The parameter passed to the <see cref="IGenericExternalEventHandler{TParameter,TResult}" />
        /// </param>
        /// <returns>The result generated by <see cref="IGenericExternalEventHandler{TParameter,TResult}" /></returns>
        public  Task<TResult> RaiseGlobal<THandler, TParameter, TResult>(TParameter parameter)
            where THandler : IGenericExternalEventHandler<TParameter, TResult>
        {
            if (RegisteredExternalEvents.TryGetValue(typeof(THandler), out var pair))
            {
                return pair.RunAsync<TParameter, TResult>(parameter);
            }

            return TaskUtils.FromResult(default(TResult));
        }

        /// <summary>
        ///     Register an <see cref="IGenericExternalEventHandler{TParameter,TResult}" /> to globally to be
        ///     raised. If a global handler is not what you want, make use of a RevitTask instance to register a scoped handler
        /// </summary>
        /// <typeparam name="TParameter">
        ///     The type of the parameter that
        ///     <see cref="IGenericExternalEventHandler{TParameter,TResult}" /> accepts
        /// </typeparam>
        /// <typeparam name="TResult">
        ///     The type of result that <see cref="IGenericExternalEventHandler{TParameter,TResult}" />
        ///     generates
        /// </typeparam>
        /// <param name="handler">The instance of <see cref="IGenericExternalEventHandler{TParameter,TResult}" /></param>
        public void RegisterGlobal<TParameter, TResult>(IGenericExternalEventHandler<TParameter, TResult> handler)
        {
            RegisteredExternalEvents.TryAdd(handler.GetType(), new ExternalEventPair(handler));
        }

        /// <summary>
        ///     Running Revit API code and get the result asynchronously
        /// </summary>
        /// <typeparam name="TResult">The type of the Result</typeparam>
        /// <param name="function">The delegate method wraps all the Revit API code with <see cref="UIApplication" /> as argument</param>
        /// <returns>The result</returns>
        public Task<TResult> RunAsync<TResult>(Func<UIApplication, TResult> function)
        {
            var externalEventPair = SyncDelegateExternalEvents.GetOrAdd(typeof(TResult), _ =>
            {
                var handler = new SyncDelegateExternalEventHandler<TResult>();
                return new ExternalEventPair(handler, () => CreateExternalEvent(handler));
            });
            return externalEventPair.RunAsync<Func<UIApplication, TResult>, TResult>(function);
        }

        /// <summary>
        ///     Running Revit API code and get the result asynchronously
        /// </summary>
        /// <typeparam name="TResult">The type of the Result</typeparam>
        /// <param name="function">
        ///     The delegate method wraps all the Revit API code and some other asynchronous processes with
        ///     <see cref="UIApplication" /> as argument
        /// </param>
        /// <returns></returns>
        public Task<TResult> RunAsync<TResult>(Func<UIApplication, Task<TResult>> function)
        {
            var externalEventPair = AsyncDelegateExternalEvents.GetOrAdd(typeof(TResult), _ =>
            {
                var handler = new AsyncDelegateExternalEventHandler<TResult>();
                return new ExternalEventPair(handler, () => CreateExternalEvent(handler));
            });
            return externalEventPair.RunAsync<Func<UIApplication, Task<TResult>>, TResult>(function);
        }

        /// <summary>
        ///     Create a new <see cref="ExternalEvent" /> for an <see cref="IExternalEventHandler" /> instance
        /// </summary>
        /// <param name="handler">The <see cref="IExternalEventHandler" /> instance</param>
        /// <returns>The <see cref="ExternalEvent" /> created</returns>
        private  Task<ExternalEvent> CreateExternalEvent(IExternalEventHandler handler)
        {
            return ExternalEventCreator.RunAsync<Func<UIApplication, ExternalEvent>, ExternalEvent>(app => ExternalEvent.Create(handler));
        }
    }
}
